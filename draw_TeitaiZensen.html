<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>停滞前線 作画ツール</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }
        #canvas-container {
            border: 2px dashed #ccc;
            background-color: white;
            background-image:
                linear-gradient(45deg, #eee 25%, transparent 25%),
                linear-gradient(-45deg, #eee 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #eee 75%),
                linear-gradient(-45deg, transparent 75%, #eee 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            min-width: 250px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        label {
            font-weight: bold;
            color: #555;
        }
        input[type="file"], select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: white;
            transition: background-color 0.3s;
        }
        #clearBtn { background-color: #f44336; }
        #clearBtn:hover { background-color: #d32f2f; }
        #downloadBtn { background-color: #4CAF50; }
        #downloadBtn:hover { background-color: #388E3C; }
    </style>
</head>
<body>

    <h1>停滞前線 作画ツール</h1>
    <p>地図画像をアップロードし、キャンバス上をクリックして前線を描画してください。</p>

    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label for="bgUpload">1. 背景画像のアップロード</label>
                <input type="file" id="bgUpload" accept="image/*">
            </div>
            <div class="control-group">
                <label for="qualitySelect">2. 出力画質</label>
                <select id="qualitySelect">
                    <option value="1">低画質（Web共有向け / 等倍）</option>
                    <option value="2" selected>標準（画面表示向け / 2倍）</option>
                    <option value="3">高画質（印刷推奨 / 3倍）</option>
                    <option value="4">最高画質（大判印刷向け / 4倍）</option>
                </select>
            </div>
            <div class="control-group">
                 <label>3. 操作</label>
                <button id="downloadBtn">PNGとしてダウンロード</button>
                <button id="clearBtn">前線をクリア</button>
            </div>
        </div>
        <div id="canvas-container">
            <canvas id="weatherCanvas" width="800" height="600"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('weatherCanvas');
        const ctx = canvas.getContext('2d');
        const bgUpload = document.getElementById('bgUpload');
        const qualitySelect = document.getElementById('qualitySelect'); // IDを変更
        const clearBtn = document.getElementById('clearBtn');
        const downloadBtn = document.getElementById('downloadBtn');

        let userPoints = [];
        let backgroundImage = null;
        
        const SYMBOL_SPACING = 40;
        const SYMBOL_SIZE = 9;
        const LINE_WIDTH = 2.5;

        // --- イベントリスナー ---

        bgUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    backgroundImage = img;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    draw();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            userPoints.push({ x, y });
            flashPoint(x, y);
        });

        clearBtn.addEventListener('click', () => {
            userPoints = [];
            draw();
        });

        downloadBtn.addEventListener('click', () => {
            // プルダウンメニューからスケール値を取得
            const scale = parseFloat(qualitySelect.value);
            
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = canvas.width * scale;
            offscreenCanvas.height = canvas.height * scale;
            const offCtx = offscreenCanvas.getContext('2d');
            
            if (backgroundImage) {
                offCtx.drawImage(backgroundImage, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
            }
            
            if (userPoints.length < 2) return;

            const scaledPoints = userPoints.map(p => ({ x: p.x * scale, y: p.y * scale }));
            const scaledParams = {
                spacing: SYMBOL_SPACING * scale,
                size: SYMBOL_SIZE * scale,
                width: LINE_WIDTH * scale
            };
            
            const smoothPath = getSplinePoints(scaledPoints);
            drawStationaryFront(smoothPath, offCtx, scaledParams);

            const link = document.createElement('a');
            link.download = `stationary_front_${offscreenCanvas.width}x${offscreenCanvas.height}.png`;
            link.href = offscreenCanvas.toDataURL('image/png');
            link.click();
        });

        // --- 描画メイン関数 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0);
            }
            if (userPoints.length < 2) return;

            const smoothPath = getSplinePoints(userPoints);
            drawStationaryFront(smoothPath, ctx, {
                spacing: SYMBOL_SPACING,
                size: SYMBOL_SIZE,
                width: LINE_WIDTH
            });
        }
        
        function flashPoint(x, y) {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();
            setTimeout(draw, 150);
        }
        
        // --- 描画ヘルパー関数 ---
        function getSplinePoints(points) {
            const splinePoints = [];
            for (let i = 0; i < points.length - 1; i++) {
                const p0 = (i > 0) ? points[i - 1] : points[i];
                const p1 = points[i];
                const p2 = points[i + 1];
                const p3 = (i < points.length - 2) ? points[i + 2] : p2;
                for (let j = 0; j < 20; j++) {
                    const t = j / 20;
                    const x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t * t + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t * t * t);
                    const y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t * t + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t * t * t);
                    splinePoints.push({ x, y });
                }
            }
            splinePoints.push(points[points.length-1]);
            return splinePoints;
        }

        function drawStationaryFront(path, context, params) {
            let distanceAlongPath = 0;
            let nextSymbolPosition = params.spacing / 2;
            
            context.lineWidth = params.width;
            context.lineCap = 'round';
            context.lineJoin = 'round';

            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i+1];
                const segmentDx = p2.x - p1.x;
                const segmentDy = p2.y - p1.y;
                const segmentLength = Math.sqrt(segmentDx * segmentDx + segmentDy * segmentDy);
                const symbolIndex = Math.floor(distanceAlongPath / params.spacing);
                context.strokeStyle = (symbolIndex % 2 === 0) ? 'red' : 'blue';
                
                context.beginPath();
                context.moveTo(p1.x, p1.y);
                context.lineTo(p2.x, p2.y);
                context.stroke();
                
                if (distanceAlongPath < nextSymbolPosition && (distanceAlongPath + segmentLength) >= nextSymbolPosition) {
                    const ratio = (nextSymbolPosition - distanceAlongPath) / segmentLength;
                    const symbolX = p1.x + ratio * segmentDx;
                    const symbolY = p1.y + ratio * segmentDy;
                    const angle = Math.atan2(segmentDy, segmentDx);

                    if (symbolIndex % 2 === 0) {
                        drawSemicircle(symbolX, symbolY, angle, context, params);
                    } else {
                        drawTriangle(symbolX, symbolY, angle, context, params);
                    }
                    nextSymbolPosition += params.spacing;
                }
                distanceAlongPath += segmentLength;
            }
        }

        function drawSemicircle(x, y, angle, context, params) {
            context.save();
            context.translate(x, y);
            context.rotate(angle);
            context.beginPath();
            context.arc(0, 0, params.size, Math.PI, 2 * Math.PI, false);
            context.fillStyle = 'red';
            context.fill();
            context.restore();
        }

        function drawTriangle(x, y, angle, context, params) {
            context.save();
            context.translate(x, y);
            context.rotate(angle);
            context.beginPath();
            context.moveTo(0, params.size * 1.2);
            context.lineTo(-params.size, 0);
            context.lineTo(params.size, 0);
            context.closePath();
            context.fillStyle = 'blue';
            context.fill();
            context.restore();
        }
    </script>

</body>
</html>
