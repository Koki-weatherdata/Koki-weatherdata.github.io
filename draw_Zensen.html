<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>停滞前線 作画ツール</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }
        #canvas-container {
            border: 2px dashed #ccc;
            background-color: white;
            background-image:
                linear-gradient(45deg, #eee 25%, transparent 25%),
                linear-gradient(-45deg, #eee 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #eee 75%),
                linear-gradient(-45deg, transparent 75%, #eee 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            min-width: 250px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        label {
            font-weight: bold;
            color: #555;
            margin-bottom: 4px;
        }
        input[type="file"], select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
        }
        .color-picker-container {
            display: flex;
            justify-content: space-around;
            gap: 10px;
        }
        .color-picker-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        input[type="color"] {
            width: 50px;
            height: 30px;
            border: 1px solid #ccc;
            padding: 0;
            border-radius: 4px;
            cursor: pointer;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: white;
            transition: background-color 0.3s;
        }
        #downloadBtn { background-color: #4CAF50; }
        #downloadBtn:hover { background-color: #388E3C; }
        .action-buttons button {
             width: 100%;
        }
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #clearBtn { background-color: #f44336; }
        #clearBtn:hover { background-color: #d32f2f; }
        #removeBgBtn { background-color: #ff9800; }
        #removeBgBtn:hover { background-color: #f57c00; }
        
        /* --- 説明セクションのスタイル --- */
        .usage-guide {
            margin-top: 40px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 90%;
            border-top: 5px solid #4CAF50;
        }
        .usage-guide h2 {
            margin-top: 0;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
            font-size: 1.2em;
        }
        .usage-guide ul {
            padding-left: 20px;
            line-height: 1.7;
            color: #333;
        }
        .usage-guide li {
            margin-bottom: 10px;
        }
        .usage-guide li strong {
            color: #d32f2f;
        }

    </style>
</head>
<body>

    <h1>停滞前線 作画ツール</h1>
    <p>各種設定を調整して、停滞前線を描画できます。</p>

    <div class="container">
        <div class="controls">
            <div class="control-group">
                <label for="bgUpload">背景画像</label>
                <input type="file" id="bgUpload" accept="image/*">
            </div>
            <div class="control-group">
                <label for="sizeSelect">前線のサイズ</label>
                <select id="sizeSelect">
                    <option value="0.75">小</option>
                    <option value="1" selected>中（デフォルト）</option>
                    <option value="1.5">大</option>
                </select>
            </div>
             <div class="control-group">
                <label>3. カラー設定</label>
                <div class="color-picker-container">
                    <div class="color-picker-wrapper">
                        <label for="redColorPicker">赤色</label>
                        <input type="color" id="redColorPicker" value="#FF0000">
                    </div>
                    <div class="color-picker-wrapper">
                        <label for="blueColorPicker">青色</label>
                        <input type="color" id="blueColorPicker" value="#0000FF">
                    </div>
                </div>
            </div>
            <div class="control-group">
                <label for="qualitySelect">出力画質</label>
                <select id="qualitySelect">
                    <option value="1">低画質（Web共有向け / 等倍）</option>
                    <option value="2" selected>標準（画面表示向け / 2倍）</option>
                    <option value="3">高画質（印刷推奨 / 3倍）</option>
                    <option value="4">最高画質（大判印刷向け / 4倍）</option>
                </select>
            </div>
            <div class="control-group">
                 <label>操作</label>
                 <div class="action-buttons">
                    <button id="downloadBtn">PNGとしてダウンロード</button>
                    <button id="removeBgBtn">背景画像のみ削除</button>
                    <button id="clearBtn">全てクリア</button>
                 </div>
            </div>
        </div>
        <div id="canvas-container">
            <canvas id="weatherCanvas" width="800" height="600"></canvas>
        </div>
    </div>
    
    <div class="usage-guide">
        <h2>ツールの使い方</h2>
        <ul>
            <li>停滞前線を作画することができます。クリックした点が滑らかに結ばれます。</li>
            <li>背景画像をアップロードせずに、背景が透明なpngとして出力することもできます。</li>
            <li><strong>【重要】</strong>前線の記号は、線の進行方向に対して上が赤い半円（赤）、青い三角形（青）となります。そのため、**基本的に右から左に向かってクリック**しないと、前線の向きが一般的な天気図と逆になってしまいます。</li>
            <li>長い前線を少ないクリック数で一気に描くと、カーブの角度計算が追い付かず、赤い半円や青い三角が連続で表示されることがあります。**なるべく短い間隔で点をクリック**すると改善します。</li>
            <li>今後は寒冷前線や温暖前線、閉塞前線も描画できるようにUpdateする予定です。</li>
        </ul>
    </div>
    <script>
        const canvas = document.getElementById('weatherCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- コントロール要素 ---
        const bgUpload = document.getElementById('bgUpload');
        const qualitySelect = document.getElementById('qualitySelect');
        const sizeSelect = document.getElementById('sizeSelect');
        const redColorPicker = document.getElementById('redColorPicker');
        const blueColorPicker = document.getElementById('blueColorPicker');
        const clearBtn = document.getElementById('clearBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const removeBgBtn = document.getElementById('removeBgBtn');

        // --- 状態変数 ---
        let userPoints = [];
        let backgroundImage = null;
        let frontColorRed = '#FF0000';
        let frontColorBlue = '#0000FF';
        let sizeMultiplier = 1.0;

        // --- 定数 ---
        const BASE_PARAMS = {
            spacing: 40,
            size: 9,
            width: 2.5
        };

        // --- イベントリスナー ---

        // 背景アップロード
        bgUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    backgroundImage = img;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    draw();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });

        // キャンバスクリック
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            userPoints.push({ x, y });
            flashPoint(x, y);
        });

        // 背景画像を削除
        removeBgBtn.addEventListener('click', () => {
            backgroundImage = null;
            bgUpload.value = ''; // ファイル選択もリセット
            draw();
        });
        
        // 全てクリア
        clearBtn.addEventListener('click', () => {
            userPoints = [];
            backgroundImage = null;
            bgUpload.value = '';
            canvas.width = 800;
            canvas.height = 600;
            draw();
        });

        // 色やサイズの設定が変更されたら再描画
        redColorPicker.addEventListener('input', (e) => { frontColorRed = e.target.value; draw(); });
        blueColorPicker.addEventListener('input', (e) => { frontColorBlue = e.target.value; draw(); });
        sizeSelect.addEventListener('change', (e) => { sizeMultiplier = parseFloat(e.target.value); draw(); });
        
        // ダウンロード
        downloadBtn.addEventListener('click', () => {
            const scale = parseFloat(qualitySelect.value);
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = canvas.width * scale;
            offscreenCanvas.height = canvas.height * scale;
            const offCtx = offscreenCanvas.getContext('2d');
            
            if (backgroundImage) {
                offCtx.drawImage(backgroundImage, 0, 0, offscreenCanvas.width, offscreenCanvas.height);
            }
            
            if (userPoints.length < 2) {
                 alert("前線を描画してください。");
                 return;
            }

            const currentSize = sizeMultiplier;
            const scaledPoints = userPoints.map(p => ({ x: p.x * scale, y: p.y * scale }));
            const scaledParams = {
                spacing: BASE_PARAMS.spacing * currentSize * scale,
                size: BASE_PARAMS.size * currentSize * scale,
                width: BASE_PARAMS.width * currentSize * scale
            };
            
            const smoothPath = getSplinePoints(scaledPoints);
            drawStationaryFront(smoothPath, offCtx, scaledParams);

            const link = document.createElement('a');
            link.download = `stationary_front_${offscreenCanvas.width}x${offscreenCanvas.height}.png`;
            link.href = offscreenCanvas.toDataURL('image/png');
            link.click();
        });

        // --- 描画メイン関数 ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (backgroundImage) {
                ctx.drawImage(backgroundImage, 0, 0);
            }
            if (userPoints.length < 2) return;
            
            const currentParams = {
                spacing: BASE_PARAMS.spacing * sizeMultiplier,
                size: BASE_PARAMS.size * sizeMultiplier,
                width: BASE_PARAMS.width * sizeMultiplier
            };
            const smoothPath = getSplinePoints(userPoints);
            drawStationaryFront(smoothPath, ctx, currentParams);
        }
        
        function flashPoint(x, y) {
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fill();
            setTimeout(draw, 150);
        }
        
        // --- 描画ヘルパー関数 ---
        function getSplinePoints(points) {
            const splinePoints = [];
            for (let i = 0; i < points.length - 1; i++) {
                const p0 = (i > 0) ? points[i - 1] : points[i];
                const p1 = points[i];
                const p2 = points[i + 1];
                const p3 = (i < points.length - 2) ? points[i + 2] : p2;
                for (let j = 0; j < 20; j++) {
                    const t = j / 20;
                    const x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t * t + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t * t * t);
                    const y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t * t + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t * t * t);
                    splinePoints.push({ x, y });
                }
            }
            splinePoints.push(points[points.length-1]);
            return splinePoints;
        }

        function drawStationaryFront(path, context, params) {
            let distanceAlongPath = 0;
            let nextSymbolPosition = params.spacing / 2;
            
            context.lineWidth = params.width;
            context.lineCap = 'round';
            context.lineJoin = 'round';

            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i+1];
                const segmentDx = p2.x - p1.x;
                const segmentDy = p2.y - p1.y;
                const segmentLength = Math.sqrt(segmentDx * segmentDx + segmentDy * segmentDy);
                const symbolIndex = Math.floor(distanceAlongPath / params.spacing);
                
                context.strokeStyle = (symbolIndex % 2 === 0) ? frontColorRed : frontColorBlue;
                
                context.beginPath();
                context.moveTo(p1.x, p1.y);
                context.lineTo(p2.x, p2.y);
                context.stroke();
                
                if (distanceAlongPath < nextSymbolPosition && (distanceAlongPath + segmentLength) >= nextSymbolPosition) {
                    const ratio = (nextSymbolPosition - distanceAlongPath) / segmentLength;
                    const symbolX = p1.x + ratio * segmentDx;
                    const symbolY = p1.y + ratio * segmentDy;
                    const angle = Math.atan2(segmentDy, segmentDx);

                    if (symbolIndex % 2 === 0) {
                        drawSemicircle(symbolX, symbolY, angle, context, params);
                    } else {
                        drawTriangle(symbolX, symbolY, angle, context, params);
                    }
                    nextSymbolPosition += params.spacing;
                }
                distanceAlongPath += segmentLength;
            }
        }

        function drawSemicircle(x, y, angle, context, params) {
            context.save();
            context.translate(x, y);
            context.rotate(angle);
            context.beginPath();
            context.arc(0, 0, params.size, Math.PI, 2 * Math.PI, false);
            context.fillStyle = frontColorRed;
            context.fill();
            context.restore();
        }

        function drawTriangle(x, y, angle, context, params) {
            context.save();
            context.translate(x, y);
            context.rotate(angle);
            context.beginPath();
            context.moveTo(0, params.size * 1.2);
            context.lineTo(-params.size, 0);
            context.lineTo(params.size, 0);
            context.closePath();
            context.fillStyle = frontColorBlue;
            context.fill();
            context.restore();
        }
    </script>

</body>
</html>


